/*! 1.0.0 */
function extractTypeCategory(type) {
    return type.substring(0, type.indexOf('/'));
}
function extractTypeName(type) {
    return type.substring(type.indexOf('/') + 1);
}

const actionNodes = {
    set: (input, context) => {
        var _a, _b;
        (_a = context.setCallback) === null || _a === void 0 ? void 0 : _a.call(context, input.parameters.target, input.parameters.value);
        return { nextFlow: (_b = input.flow) === null || _b === void 0 ? void 0 : _b.next, result: {} };
    },
    get: (input, context) => {
        var _a, _b;
        let value;
        value = (_a = context.getCallback) === null || _a === void 0 ? void 0 : _a.call(context, input.parameters.source);
        return { nextFlow: (_b = input.flow) === null || _b === void 0 ? void 0 : _b.next, result: { result: value } };
    },
    setVariable: (input, context) => {
        var _a, _b;
        (_a = context.setVariable) === null || _a === void 0 ? void 0 : _a.call(context, input.parameters.variable, input.parameters.value);
        return { nextFlow: (_b = input.flow) === null || _b === void 0 ? void 0 : _b.next, result: {} };
    },
    animations: {
        setTime: (input, context) => {
            var _a, _b;
            (_a = context.animationSetTimeCallback) === null || _a === void 0 ? void 0 : _a.call(context, input.parameters.animation, input.parameters.time);
            return { nextFlow: (_b = input.flow) === null || _b === void 0 ? void 0 : _b.next, result: {} };
        },
        setPlaying: (input, context) => {
            var _a, _b;
            (_a = context.animationSetPlayingCallback) === null || _a === void 0 ? void 0 : _a.call(context, input.parameters.animation, input.parameters.isPlaying);
            return { nextFlow: (_b = input.flow) === null || _b === void 0 ? void 0 : _b.next, result: {} };
        },
        reset: (input, context) => {
            var _a, _b;
            (_a = context.animationResetCallback) === null || _a === void 0 ? void 0 : _a.call(context, input.parameters.animation);
            return { nextFlow: (_b = input.flow) === null || _b === void 0 ? void 0 : _b.next, result: {} };
        },
        setSpeed: (input, context) => {
            var _a, _b;
            (_a = context.animationSetSpeedCallback) === null || _a === void 0 ? void 0 : _a.call(context, input.parameters.animation, input.parameters.speed);
            return { nextFlow: (_b = input.flow) === null || _b === void 0 ? void 0 : _b.next, result: {} };
        },
        setRepetitions: (input, context) => {
            var _a, _b;
            (_a = context.animationSetSpeedCallback) === null || _a === void 0 ? void 0 : _a.call(context, input.parameters.animation, input.parameters.repetitions);
            return { nextFlow: (_b = input.flow) === null || _b === void 0 ? void 0 : _b.next, result: {} };
        }
    }
};

const flowNodes = {
    branch: (input, context) => {
        var _a, _b;
        return { nextFlow: input.parameters.condition ? (_a = input.flow) === null || _a === void 0 ? void 0 : _a.true : (_b = input.flow) === null || _b === void 0 ? void 0 : _b.false, result: {} };
    }
};

function scalarToArray(value) {
    if (typeof value === "number") {
        return [value];
    }
    return value;
}
function arrayToScalar(value) {
    if (value.length === 1) {
        return value[0];
    }
    return value;
}
const mathNodes = {
    add: (input, context) => {
        var _a;
        const first = scalarToArray(input.parameters.first);
        const second = scalarToArray(input.parameters.second);
        const next = (_a = input.flow) === null || _a === void 0 ? void 0 : _a.next;
        const result = first;
        for (let i = 0; i < first.length; ++i) {
            result[i] = first[i] + second[i];
        }
        return { nextFlow: next, result: { result: arrayToScalar(result) } };
    },
    subtract: (input, context) => {
        var _a;
        const first = scalarToArray(input.parameters.first);
        const second = scalarToArray(input.parameters.second);
        const next = (_a = input.flow) === null || _a === void 0 ? void 0 : _a.next;
        const result = first;
        for (let i = 0; i < first.length; ++i) {
            result[i] = first[i] - second[i];
        }
        return { nextFlow: next, result: { result: arrayToScalar(result) } };
    },
    less: (input, context) => {
        var _a;
        const first = scalarToArray(input.parameters.first);
        const second = scalarToArray(input.parameters.second);
        const next = (_a = input.flow) === null || _a === void 0 ? void 0 : _a.next;
        let compareResult = true;
        for (let i = 0; i < first.length; ++i) {
            compareResult = compareResult && (first[i] < second[i]);
        }
        return { nextFlow: next, result: { result: compareResult } };
    },
    multiply: (input, context) => {
        var _a;
        const first = scalarToArray(input.parameters.first);
        const second = scalarToArray(input.parameters.second);
        const next = (_a = input.flow) === null || _a === void 0 ? void 0 : _a.next;
        const result = first;
        for (let i = 0; i < first.length; ++i) {
            result[i] = first[i] * second[i];
        }
        return { nextFlow: next, result: { result: arrayToScalar(result) } };
    }
};

const nodes = {
    math: mathNodes,
    flow: flowNodes,
    action: actionNodes
};
function isNodeFunction(entry) {
    return typeof entry === "function";
}
function getNode(type) {
    const identifiers = type.split("/");
    let currentRef = nodes;
    for (const identifier of identifiers.slice(0, -1)) {
        const nextRef = currentRef[identifier];
        if (isNodeFunction(nextRef)) {
            throw new Error(`Invalid node type ${type}`);
        }
        else {
            currentRef = nextRef;
        }
    }
    const lastIdentifier = identifiers.pop();
    if (!lastIdentifier || !(lastIdentifier in currentRef) || !isNodeFunction(currentRef[lastIdentifier])) {
        throw new Error(`Invalid node type ${type}`);
    }
    else {
        // We can be sure that it is a NodeFunction as we checked it in the if clause
        return currentRef[lastIdentifier];
    }
}

class Behavior {
    constructor(behaviorExtensionObject) {
        this.events = {};
        this.context = {};
        this._nodeState = {};
        this._variableState = {};
        this.behaviorExtensionData = behaviorExtensionObject;
        // Collect events that belong to this extension
        this.behaviorExtensionData.nodes.forEach((node, index) => {
            if (extractTypeCategory(node.type) === "event") {
                const typeName = extractTypeName(node.type);
                if (!(typeName in this.events)) {
                    this.events[typeName] = [];
                }
                this.events[typeName] = [...this.events[typeName], index];
            }
        });
        if (this.behaviorExtensionData.variables) {
            Object.entries(this.behaviorExtensionData.variables).forEach(([variableName, variable]) => {
                this._variableState[variableName] = variable.value;
            });
        }
        this.context = {
            setVariable: (variable, value) => {
                this._variableState[variable] = value;
            }
        };
    }
    runOnEvent(eventName, data) {
        if (eventName in this.events) {
            this.events[eventName].forEach((nodeIndex) => {
                this.run(nodeIndex, this.behaviorExtensionData.nodes, data);
            });
        }
    }
    onUpdate() {
        this.runOnEvent("onUpdate");
    }
    onStart() {
        this.runOnEvent("onStart");
    }
    onEvent(eventName, eventData) {
        this.runOnEvent(`on${eventName}Event`, eventData);
    }
    getState(nodeIndex) {
        return this._nodeState[nodeIndex];
    }
    getVariable(variableName) {
        return this._variableState[variableName];
    }
    runFromNode(nodeIndex) {
        this.run(nodeIndex, this.behaviorExtensionData.nodes);
    }
    run(entryIndex, behaviorNodes, initialState) {
        var _a;
        // Ensure no state can leak between individual runs
        this._nodeState = {};
        // Initialize state with the data from the input event, so that subsequent nodes can access it
        if (initialState) {
            this.makeState(entryIndex);
            this._nodeState[entryIndex] = initialState;
        }
        // Evaluate the graph node by node
        let currentIndex = (_a = behaviorNodes[entryIndex].flow) === null || _a === void 0 ? void 0 : _a.next;
        while (currentIndex !== undefined) {
            currentIndex = this.evalNode(currentIndex, behaviorNodes[currentIndex]);
        }
    }
    evalNode(index, node) {
        // Extract all references from the state, so that the nodes don't need to differntiate between
        // references and literal values
        const parameters = {};
        for (const [paramName, paramValue] of Object.entries(node.parameters || {})) {
            if (typeof paramValue === "object" && "$node" in paramValue) {
                parameters[paramName] =
                    this._nodeState[paramValue.$node][paramValue.socket];
                continue;
            }
            else if (typeof paramValue === "object" &&
                "$variable" in paramValue) {
                parameters[paramName] =
                    this._variableState[paramValue.$variable];
            }
            else {
                parameters[paramName] = paramValue;
            }
        }
        const nodeFunction = getNode(node.type);
        const output = nodeFunction({ parameters, flow: node.flow }, this.context);
        this.makeState(index);
        for (const [socketName, socketValue] of Object.entries(output.result)) {
            this._nodeState[index][socketName] = socketValue;
        }
        return output.nextFlow;
    }
    makeState(index) {
        if (!(index in this._nodeState)) {
            this._nodeState[index] = {};
        }
    }
}

export { Behavior };
//# sourceMappingURL=bundle.module.js.map
